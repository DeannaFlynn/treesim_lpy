"""
Tying, Pruning and labeling UFO architecture trees
"""
import sys
sys.path.append('../')
from stochastic_tree import BasicWood
from architecture import Architecture, WireVector
import operators
import numpy as np
import random as rd
import copy
import gc
import time
import helper
import scheduler
from scipy.stats import poisson

class Spur(BasicWood):

    COUNT = 0

    def get_branch_growth_on_segment(self, start, end):
        return []


class Branch(BasicWood):

    COUNT = 0

    def get_branch_growth_on_segment(self, start, end):
        branches = []
        n_spurs = poisson((end - start) * 0.1).rvs()
        positions = np.sort(np.random.uniform(0, end-start, n_spurs))
        for pos in positions:
            spur = Spur(thickness_schedule=scheduler.ExponentialScheduler(0.5, 1.0, 1.0, True),
                        length_schedule=scheduler.ExponentialScheduler(0.005, 0.01, 1.0, True),
                        color=2)
            branches.append((pos, spur))

        return branches


class Trunk(BasicWood):

    COUNT = 0

    def get_branch_growth_on_segment(self, start, end):
        if self.length < 5:
            return []

        branches = []
        spurs = poisson(0.8 * 0.2 * (end - start)).rvs()
        leaders = poisson(0.2 * 0.2 * (end - start)).rvs()

        print('DEL: {}'.format(end - start))
        print('START: {}'.format(start))
        print('END: {}'.format(end))
        print('SPURS: {}'.format(spurs))
        print('LEADERS: {}'.format(leaders))

        for _ in range(spurs):
            spur = Spur(
                thickness_schedule=scheduler.ExponentialScheduler(0.5, 1.0, 1.0, True),
                length_schedule=scheduler.ExponentialScheduler(0.005, 0.01, 1.0, True),
                color=2
            )
            branches.append((np.random.uniform(0, start), spur))

        for _ in range(leaders):
            leader = Branch(
                thickness_schedule=scheduler.ExponentialScheduler(0.015, 0.03, 1.0, True),
                length_schedule=scheduler.LinearScheduler(1, 20, 19, bound_end=True),
                color = 1, can_tie=True
            )
            branches.append((np.random.uniform(0, end-start), leader))

        return branches


#init  
trunk_base = Trunk(
    length_schedule=scheduler.LinearScheduler(1, 20, 19, bound_end=True),
    thickness_schedule=scheduler.ExponentialScheduler(0.05, 0.20, k=4, as_half_life=True),
    color = 0, can_tie=True)
time_count = 0


# Define the architecture
x_pts = (np.arange(7) + 1) * 3
arch = Architecture()
arch['trunk'] = WireVector((0,0,3), (21, 0, 3), one_sided=False)
trunk_base.update_guide(arch['trunk'])
for x in x_pts:
    arch.add_item('leader', WireVector((x,0,0), (x,0,21)))

num_iteration_tie = 5
MAX_SEG_LEN = 0.5
SHOW_JOINTS = True

def End(lstring, geometries):
    print(geometries)
    print(dir(geometries))

def StartEach(lstring):
    global parent_child_dict, arch, trunk_base
    trunk_wire = arch.get('trunk', None)
    if trunk_wire is not None and not trunk_base.tie_updated:
        trunk_base.tie_update()

    print(trunk_base.start, trunk_base.end)

    for i in parent_child_dict[trunk_base.name]:
        if i.tie_updated == False:
            i.tie_update()

def EndEach(lstring):
    global parent_child_dict, arch

    tied = False
    if (getIterationNb()+1)%num_iteration_tie == 0:
        trunk_wire = arch.get('trunk', None)
        if trunk_wire is not None:
            trunk_base.update_guide(trunk_base.guide_target) #Tie trunk one iteration before branches

        branches = parent_child_dict[trunk_base.name]
        i_branch, i_wire = helper.determine_branch_wire_pairing(branches, arch['leader'], max_energy=300)
        if i_branch is not None:
            branches[i_branch].guide_target = arch['leader'][i_wire]
            arch['leader'][i_wire].add_branch()

        for branch in parent_child_dict[trunk_base.name]:
            branch.update_guide(branch.guide_target)
            print(branch.name, branch.guide_target)
        while operators.tie_all(lstring):
            pass
        while pruning_strategy(lstring):
            pass
    return lstring

def pruning_strategy(lstring): #Remove remnants of cut

    for idx, lsys_elem in enumerate(lstring):
        if lsys_elem.name != 'C':
            continue
        wood = lsys_elem[0].type
        if wood.age > 8 and not wood.has_tied and not wood.cut:
            wood.cut = True
            print("Cutting", wood.name)
            helper.cut_from(idx, lstring)
            return True
    return False

parent_child_dict = {}
parent_child_dict[trunk_base.name] = []
label = True
#print(generate_points_ufo())
#Tie trunk
module Attractors
module grow_object
module produce_buds
module bud
module branch
module C
Axiom: Attractors(arch)@GcGetPos(trunk_base.start)T(ParameterSet(type = trunk_base))&(270)grow_object(trunk_base)GetPos(trunk_base.end)@Ge
derivation length: 50

production:
#Decide whether branch internode vs trunk internode need to be the same size.
grow_object(ob) :
    len_change, new_branches = ob.grow_one()
    new_branches.sort(key=lambda x: x[0])
    cur_pos = 0
    if label:
        nproduce SetColor(ob.color)

    for pos, new_obj in new_branches:

        print('PRODUCING {}'.format(new_obj))

        pos_del = pos - cur_pos
        nproduce I(pos_del, ob.thickness, ob)
        if SHOW_JOINTS and (isinstance(ob, Branch) and isinstance(new_obj, Spur)):
            nproduce[SetColor(0, 0, 255) @ O(0.3)]
        nproduce bud(ParameterSet(type=new_obj))
        cur_pos = pos
        # Bookkeeping
        parent_child_dict[new_obj.name] = []
        parent_child_dict[ob.name].append(new_obj)
        ob.num_branches += 1

    nproduce I(len_change - cur_pos, ob.thickness, ob)
    produce grow_object(ob)

bud(param_set):
    wood = param_set.type
    produce [@Gc@RGetPos(wood.start)C(ParameterSet(type = wood))/(rd.random()*360)&(rd.random()*90)grow_object(wood)GetPos(wood.end)@Ge]


I(s,r,o) --> I(s,o.thickness, o)

homomorphism:
I(a,r,o) --> F(a,r)

production:
Attractors(arch):
    pttodisplay = arch.attractor_grid.get_enabled_points()
    if len(pttodisplay) > 0:
        produce [,(3) @g(PointSet(pttodisplay,width=10))]
