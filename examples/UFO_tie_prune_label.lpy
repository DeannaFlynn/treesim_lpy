"""
Tying, Pruning and labeling UFO architecture trees
"""
import sys
sys.path.append('../')
from stochastic_tree import BasicWood
from architecture import Architecture, WireVector
#import operators
import numpy as np
import random as rd
import copy
import gc
import time
import helper

class Spur(BasicWood):

    COUNT = 0

    def is_bud_break(self, num_buds_segment):
        return (rd.random() < 0.1)

    def create_branch(self):
        return None

    def grow(self):
        pass

class Branch(BasicWood):

    COUNT = 0

    def is_bud_break(self, num_buds_segment):
        return (rd.random() < 0.1*(1 - num_buds_segment/self.max_buds_segment))

    def create_branch(self):
        new_ob = Spur(max_length = 1, thickness_increment = 0.005, color = 2)
        return new_ob

    def grow(self):
        pass

class Trunk(BasicWood):

    COUNT = 0

    def is_bud_break(self, num_buds_segment):
        if (rd.random() > 0.1*(1 - num_buds_segment/self.max_buds_segment)):
            return False
        return True

    def create_branch(self):
        if self.length < 5:
            return None
        if rd.random() > 0.8:
            return Spur(max_length = 1, thickness_increment = 0.005, color = 2)
        else:
            return Branch(max_length = 20, thickness_increment = 0.005, color = 1, can_tie=True)

    def grow(self):
        pass


#init  
trunk_base = Trunk(max_length = 20, thickness_increment = 0.01, color = 0, can_tie=True)
time_count = 0


# Define the architecture
x_pts = (np.arange(7) + 1) * 3
arch = Architecture()
arch['trunk'] = WireVector((0,0,3), (21, 0, 3), one_sided=False)
trunk_base.update_guide(arch['trunk'])
for x in x_pts:
    arch.add_item('leader', WireVector((x,0,0), (x,0,21)))

num_iteration_tie = 5

def StartEach(lstring):
    global parent_child_dict, arch, trunk_base
    trunk_wire = arch.get('trunk', None)
    if trunk_wire is not None and not trunk_base.tie_updated:
        trunk_base.tie_update()

    print(trunk_base.start, trunk_base.end)

    for i in parent_child_dict[trunk_base.name]:
        if i.tie_updated == False:
            i.tie_update()

def EndEach(lstring):
    global parent_child_dict, arch

    tied = False
    if (getIterationNb()+1)%num_iteration_tie == 0:
        trunk_wire = arch.get('trunk', None)
        if trunk_wire is not None:
            trunk_base.update_guide(trunk_base.guide_target) #Tie trunk one iteration before branches

        branches = parent_child_dict[trunk_base.name]
        i_branch, i_wire = helper.determine_branch_wire_pairing(branches, arch['leader'], max_energy=300)
        if i_branch is not None:
            branches[i_branch].guide_target = arch['leader'][i_wire]
            arch['leader'][i_wire].add_branch()

        for branch in parent_child_dict[trunk_base.name]:
            branch.update_guide(branch.guide_target)
            print(branch.name, branch.guide_target)
#        while operators.tie_all(lstring):
#            pass
        while pruning_strategy(lstring):
            pass
    return lstring

def pruning_strategy(lstring): #Remove remnants of cut

    for idx, lsys_elem in enumerate(lstring):
        if lsys_elem.name != 'C':
            continue
        wood = lsys_elem[0].type
        if wood.age > 8 and not wood.has_tied and not wood.cut:
            wood.cut = True
            print("Cutting", wood.name)
            helper.cut_from(idx, lstring)
            return True
    return False

parent_child_dict = {}
parent_child_dict[trunk_base.name] = []
label = True
#print(generate_points_ufo())
#Tie trunk
module Attractors
module grow_object
module bud
module branch
module C
Axiom: Attractors(arch)@GcGetPos(trunk_base.start)T(ParameterSet(type = trunk_base))&(270)grow_object(trunk_base)GetPos(trunk_base.end)@Ge
derivation length: 50

production:
#Decide whether branch internode vs trunk internode need to be the same size.
grow_object(ob) :
    if ob is None:
        produce *
    if ob.length >= ob.max_length:
        nproduce *
    else:
        ob.grow_one()
        if label:
            nproduce SetColor(ob.color)
        produce I(ob.growth_length, ob.thickness, ob)bud(ParameterSet(type = ob, num_buds = 0))grow_object(ob)

bud(wood) :
    if wood.type.is_bud_break(wood.num_buds):
        new_object = wood.type.create_branch()
        if new_object is None:
            produce *

        if isinstance(wood.type, Branch) and isinstance(new_object, Spur):
            nproduce [SetColor(0,0,255)@O(0.2)]

        parent_child_dict[new_object.name] = []
        parent_child_dict[wood.type.name].append(new_object)
        #Store new object somewhere
        wood.num_buds+=1
        wood.type.num_branches+=1
        nproduce [@Gc@RGetPos(new_object.start)C(ParameterSet(type = new_object))/(rd.random()*360)&(rd.random()*90)grow_object(new_object)GetPos(new_object.end)@Ge]bud(wood)


I(s,r,o) --> I(s,r+o.thickness_increment, o)


homomorphism:

I(a,r,o) --> F(a,r)

production:
Attractors(arch):
    pttodisplay = arch.attractor_grid.get_enabled_points()
    if len(pttodisplay) > 0:
        produce [,(3) @g(PointSet(pttodisplay,width=10))]

endlsystem

def EndInterpretation():
  iter = getIterationNb()
  print(iter)


def End(lstring, lscene):
  from export_models import convert_scene_to_mesh
  
  convert_scene_to_mesh(lscene, file_path='test.ply')