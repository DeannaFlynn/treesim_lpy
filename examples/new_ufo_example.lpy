import numpy as np
import networkx as nx
import sys
import os
from collections import defaultdict
import json
from networkx.readwrite import json_graph
import importlib

sys.path.append('../')

import graph_utils
import branch_operations as bops
import curves

for mod in [graph_utils, bops, curves]:
  importlib.reload(mod)


class Increment:
  def __init__(self):
    self.start = 0
  
  def __call__(self):
    return_val = self.start
    self.start += 1
    return return_val

INC = Increment()
LOGGER = defaultdict(lambda: [0, 0, 0])
LAST_LSTRING = None

TEST = None

bud_rot_factor = 360/np.random.uniform(3,5)		# Number of "revolutions" of buds in a meter of growth
trunk_start = 0.1
trunk_max = 0.3
trunk_incr = 0.025
other_start = 0.05
other_max = 0.10
other_incr = 0.01
bud_max_age = 5

targets = [bops.PointTarget([5.0, 0.0, 2.0]), bops.PointTarget([10.0, 0.0, 2.0])]
next_target = 0


module R, N, M, M_t, S		# Root, Node (generic), Meristem, Trunk meristem, Stub
module I_t, I, Dummy			# Trunk internode, regular internode, dummy
module B, B_f			# Generic bud, fruiting bud
# module Roll		# Directional module that doesn't get picked up by the tree stuff
module Flags, GlobalGuide

Axiom: R(INC())^(np.random.uniform(37.5, 52.5))Dummy@GeM_t(INC(),0,0)
# Axiom: R(INC())^(26.01)Dummy@GeM_t(INC(),0)

derivation length: 20
production:
I(l,d):
  nproduce I(l,d+min((other_max-d)/2, other_incr))
  
  
I_t(l,d):
  nproduce I_t(l,d+min((trunk_max-d)/2, trunk_incr))
  
  
M_t(id, age, prog):
  nproduce /(prog * bud_rot_factor)N(id)
  if age > 0 and np.random.uniform() < 0.5:
    nproduce [^(np.random.uniform(15, 45))B(INC(), 0.20, 0)]
  produce I_t(1,trunk_start)M_t(INC(), age+1, prog+1)

B(id, p, a):
  
  if a >= bud_max_age:
    produce B(id, p, a+1)
  
  if np.random.uniform() < p:
    produce I(1,other_start)M(id,0,0)
  
  produce B(id, p, a+1)


M(id, age, prog):
  nproduce /(prog * bud_rot_factor)N(id)
  if np.random.uniform() < 0.25:
    nproduce [^(np.random.uniform(15, 45))B(INC(), 0.10, 0)]
  produce I(1,other_start)M(INC(), age+1, prog+1)

interpretation:
I(l,d) --> SetColor(1)F(l,d)
I_t(l,d) --> SetColor(2)F(l,d)
GlobalGuide(c, l):
  produce @R(0,0,1,1,0,0)SetGuide(c,l)
# I_b --> SetColor(3)F(0.5, 0.1)


B(id, p, a) --> F(0.5, 0.1)
R(id) --> GetPos(LOGGER[id])[Frame(0.75, 0.5)]
M(id, age, prog) --> GetPos(LOGGER[id])[Frame(0.75, 0.5)]
M_t(id, age, prog) --> GetPos(LOGGER[id])[Frame(0.75, 0.5)]
N(id) --> GetPos(LOGGER[id])
Flags(*flags):
  if 1 in flags:
    produce [Frame(1.5, 0.5)]

endlsystem




def StartEach():
  return LAST_LSTRING

def EndEach(lstring):
  global LAST_LSTRING
  LAST_LSTRING = lstring
  return lstring
  
def EndInterpretation():

  
  global LAST_LSTRING
  global next_target
  global TEST
  
  
  lstring = LAST_LSTRING
  iter = getIterationNb()
  if iter and not iter % 4:
    print('Updating')
    tree = graph_utils.LStringGraphDual.from_lstring(lstring, ['R', 'N', 'M', 'M_t', 'S'], ['I_t', 'I', 'I_b', 'Dummy'], ['B', 'B_f'], ['GlobalGuide'])
    tree.set_node_attributes(LOGGER, name='position')
    
    if next_target < len(targets):
      target = targets[next_target]
      
      root_branch = tree.search_branches('generation', '=', 0, assert_unique=True)
      nodes = tree.branches[root_branch]['nodes']
      
      # Find the last internode that was tied down and return nodes for all subsequent internodes
      last_tie_idx = 0
      for idx, (n1, n2) in enumerate(zip(nodes[:-1], nodes[1:])):
        data = dict(tree.graph.edges[n1, n2].get('post_modules', []))
        if 1 in data.get('Flags', []):
          last_tie_idx = idx + 1
      print('Index of last tie: {}'.format(last_tie_idx))
      nodes = nodes[last_tie_idx:]
      pts = tree.branches[root_branch]['points'][last_tie_idx:]
      
      offsets = np.linalg.norm(pts[:-1] - pts[1:], axis=1)
      cumul_lens = np.cumsum(offsets)
      length = cumul_lens[-1]
      if length > 0:
        _, dist_to_target, _, target_pt = target.get_point_sequence_dist(pts)
        if length > dist_to_target + np.linalg.norm(target_pt - pts[0]):
          params, _, rez = curves.run_cubic_bezier_strain_opt([pts[0], target_pt], pts[2 if nodes[0] == 0 else 1]-pts[0], 1)
          if rez.success:
            print('Tying to Target {}'.format(next_target))
            curve_pts = curves.CubicBezier(*params[0]).eval(np.linspace(0, 1, 10))
            print(curve_pts)
            curve_len = np.sum(np.linalg.norm(curve_pts[:-1] - curve_pts[1:], axis=1))
            
            tie_down_node_idx = (np.argmax(cumul_lens > curve_len) or len(nodes) - 2) + 1
            tree.set_guide_on_nodes(nodes[:tie_down_node_idx + 1], curve_pts, 'GlobalGuide')
            
            #print('DEBUGGING:\nNodes:\n{}\nFirst Edge:\n{}\nLast Edge:\n{}\nL-String:\n{}\n'.format(nodes, tree.graph.edges[nodes[0], nodes[1]], tree.graph.edges[nodes[-2], nodes[-1]], tree.to_lstring()))
            next_target += 1
            
    #        import pickle
    #        with open(r'D:\Documents\Temp\test.pickle', 'wb') as fh:
    #          pickle.dump(tree, fh)
  
    
    lstring = tree.to_lstring()
    #graph = extract_skeleton_from_lstring(lstring, list('MNS'), ['I', 'I_s'])
    #nx.set_node_attributes(graph, LOGGER, name='position')
    #edges = list(graph.edges)
    #edge = edges[np.random.randint(len(edges))]
    #print('Starting len: {}'.format(len(lstring)))
    #insert_modules(lstring, 'X', [edge], 'MNS', True)
    #print('Ending len: {}'.format(len(lstring)))
    #print(lstring)
    
    #json_data = json_graph.node_link_data(graph)
    #with open('test.json', 'w') as fh:
    #  json.dump(json_data, fh)
  LAST_LSTRING = lstring
  TEST = iter
