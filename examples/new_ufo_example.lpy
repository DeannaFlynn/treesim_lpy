import numpy as np
import networkx as nx
import sys
import os
from collections import defaultdict
import json
from networkx.readwrite import json_graph
import importlib

sys.path.append('../')

import graph_utils
import branch_operations as bops
import curves

for mod in [graph_utils, bops, curves]:
  importlib.reload(mod)


class Increment:
  def __init__(self):
    self.start = 0
  
  def __call__(self):
    return_val = self.start
    self.start += 1
    return return_val

INC = Increment()
LOGGER = defaultdict(lambda: [0, 0, 0])
LAST_LSTRING = None

targets = [bops.PointTarget([5.0, 0.0, 2.0]), bops.PointTarget([10.0, 0.0, 2.0])]
next_target = 0


module R, N, M, M_t, S		# Root, Node (generic), Meristem, Trunk meristem, Stub
module I_t, I, Dummy			# Trunk internode, regular internode, dummy
module B, B_f			# Generic bud, fruiting bud
module Roll		# Directional module that doesn't get picked up by the tree stuff
module Flags

Axiom: R(INC())^(np.random.uniform(15,45))Dummy@GeM_t(INC(),0)


derivation length: 20
production:
M_t(id, age):
  nproduce Roll(60)N(id)
  if age > 0 and np.random.uniform() < 0.5:
    nproduce [^(np.random.uniform(15, 45))B(INC(), 0.20)]
  produce I_tM_t(INC(), age+1)

B(id, p):
  if np.random.uniform() < p:
    produce IM(id,0)


M(id, age):
  nproduce Roll(60)N(id)
  if np.random.uniform() < 0.25:
    nproduce [^(np.random.uniform(15, 45))B(INC(), 0.10)]
  produce IM(INC(), age+1)

interpretation:
I --> SetColor(1)F(1,0.2)
I_t --> SetColor(2)F(1,0.5)
# Roll(deg) --> /(deg)
# I_b --> SetColor(3)F(0.5, 0.1)


B(id, p) --> F(0.5, 0.1)
R(id) --> GetPos(LOGGER[id])
M(id, age) --> GetPos(LOGGER[id])
M_t(id, age) --> GetPos(LOGGER[id])
N(id) --> GetPos(LOGGER[id])



endlsystem




def StartEach():
  return LAST_LSTRING

def EndEach(lstring, lsystem):
  global LAST_LSTRING
  LAST_LSTRING = lstring
  return lstring
  
def EndInterpretation():

  
  global LAST_LSTRING
  global next_target
  
  lstring = LAST_LSTRING
  iter = getIterationNb()
  if iter and not iter % 4:
    print('Updating')
    tree = graph_utils.LStringGraphDual.from_lstring(lstring, ['R', 'N', 'M', 'M_t', 'S'], ['I_t', 'I', 'I_b', 'Dummy'], ['B', 'B_f'])
    tree.set_node_attributes(LOGGER, name='position')
    
    if next_target < len(targets):
      target = targets[next_target]
      
      root_branch = tree.search_branches('generation', '=', 0, assert_unique=True)
      nodes = tree.branches[root_branch]['nodes']
      
      # Find the last internode that was tied down and return nodes for all subsequent internodes
      last_tie_idx = 0
      for idx, (n1, n2) in enumerate(zip(nodes[:-1], nodes[1:])):
        data = dict(tree.graph.edges[n1, n2].get('post_modules', []))
        if 1 in data.get('Flags', []):
          last_tie_idx = idx + 1
      print('Index of last tie: {}'.format(last_tie_idx))
      nodes = nodes[last_tie_idx:]
      pts = tree.branches[root_branch]['points'][last_tie_idx:]
      length = np.sum(np.linalg.norm(pts[:-1] - pts[1:], axis=1))
      if length > 0:
        _, dist_to_target, _, target_pt = target.get_point_sequence_dist(pts)
        if length > dist_to_target + np.linalg.norm(target_pt - pts[0]):
          # TEMP HACK ON THE PTS[2]
          params, _, rez = curves.run_cubic_bezier_strain_opt([pts[0], target_pt], pts[2]-pts[0], 1)
          if rez.success:
            print('Tying to Target {}'.format(next_target))
            curve_pts = curves.CubicBezier(*params[0]).eval(np.linspace(0, 1, 10))
            print(curve_pts)
            tree.set_guide_on_nodes(nodes, curve_pts)
            
            print('DEBUGGING:\n{}\n{}\n{}'.format(nodes, tree.graph.edges[nodes[0], nodes[1]], tree.graph.edges[nodes[-2], nodes[-1]]))
            next_target += 1
            
    #        import pickle
    #        with open(r'D:\Documents\Temp\test.pickle', 'wb') as fh:
    #          pickle.dump(tree, fh)
  
    
    lstring = tree.to_lstring()
    #graph = extract_skeleton_from_lstring(lstring, list('MNS'), ['I', 'I_s'])
    #nx.set_node_attributes(graph, LOGGER, name='position')
    #edges = list(graph.edges)
    #edge = edges[np.random.randint(len(edges))]
    #print('Starting len: {}'.format(len(lstring)))
    #insert_modules(lstring, 'X', [edge], 'MNS', True)
    #print('Ending len: {}'.format(len(lstring)))
    #print(lstring)
    
    #json_data = json_graph.node_link_data(graph)
    #with open('test.json', 'w') as fh:
    #  json.dump(json_data, fh)
  LAST_LSTRING = lstring
